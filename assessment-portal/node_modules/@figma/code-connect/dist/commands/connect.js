"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addConnectCommandToProgram = void 0;
const parser_1 = require("../react/parser");
const fs_1 = __importDefault(require("fs"));
const upload_1 = require("../connect/upload");
const validation_1 = require("../connect/validation");
const create_1 = require("../connect/create");
const project_1 = require("../common/project");
const logging_1 = require("../common/logging");
const convert_1 = require("../storybook/convert");
const delete_docs_1 = require("../connect/delete_docs");
function addBaseCommand(command, name, description) {
    return command
        .command(name)
        .description(description)
        .usage('[options]')
        .option('-r --dir <dir>', 'directory to parse')
        .option('-t --token <token>', 'figma access token')
        .option('-v --verbose', 'enable verbose logging for debugging')
        .option('-o --outfile <file>', 'output to JSON file')
        .option('-c --config <path>', 'path to a figma config file')
        .option('--dry-run', 'tests publishing without actually publishing');
}
function addConnectCommandToProgram(program) {
    // Main command, invoked with `figma connect`
    const connectCommand = addBaseCommand(program, 'connect', 'Start the Code Connect Wizard (not implemented yet)');
    // Sub-commands, invoked with e.g. `figma connect publish`
    addBaseCommand(connectCommand, 'publish', 'Run Code Connect locally to find any files that include calls to `figma.connect()` and publishes those to Figma. ' +
        'By default this looks for a config file named "figma.config.json", and uses the `include` and `exclude` fields to determine which files to parse. ' +
        'If no config file is found, this parses the current directory. An optional `--dir` flag can be used to specify a directory to parse.')
        .option('--skip-validation', 'skip validation of Code Connect docs')
        .action(handlePublish);
    addBaseCommand(connectCommand, 'unpublish', 'Run to find any files that include calls to `figma.connect()` and unpublish them from Figma. ' +
        'By default this looks for a config file named "figma.config.json", and uses the `include` and `exclude` fields to determine which files to parse. ' +
        'If no config file is found, this parses the current directory. An optional `--dir` flag can be used to specify a directory to parse.')
        .option('--node <link_to_node>', 'specify the node to unpublish. This will unpublish for both React and Storybook.')
        .action(handleUnpublish);
    addBaseCommand(connectCommand, 'parse', 'Run Code Connect locally to find any files that include calls to `figma.connect()`, then converts to JSON and outputs to stdout.').action(handleParse);
    addBaseCommand(connectCommand, 'create', 'Generate a Code Connect file with boilerplate in the current directory for a Figma node URL')
        .argument('<figma-node-url>', 'Figma node URL to create the Code Connect file from')
        .action(handleCreate);
}
exports.addConnectCommandToProgram = addConnectCommandToProgram;
function getAccessToken(cmd) {
    return cmd.token ?? process.env.FIGMA_ACCESS_TOKEN;
}
function setupHandler(cmd) {
    if (cmd.verbose) {
        logging_1.logger.setLogLevel(logging_1.LogLevel.Debug);
    }
}
async function getCodeConnectObjects(dir, cmd, projectInfo) {
    const codeConnectObjects = [];
    const { files, remoteUrl, config, tsProgram } = projectInfo;
    const figmaNodeToFile = new Map();
    for (const file of files.filter((f) => (0, parser_1.isFigmaConnectFile)(tsProgram, f))) {
        try {
            const docs = await (0, parser_1.parse)(tsProgram, file, remoteUrl, config, cmd.verbose);
            for (const doc of docs) {
                figmaNodeToFile.set(doc.figmaNode, file);
            }
            codeConnectObjects.push(...docs);
            logging_1.logger.info((0, logging_1.success)(file));
        }
        catch (e) {
            logging_1.logger.error(`‚ùå ${file}`);
            if (e instanceof parser_1.ParserError) {
                if (cmd.verbose) {
                    console.trace(e);
                }
                else {
                    logging_1.logger.error(e.toString());
                }
            }
            else {
                if (cmd.verbose) {
                    console.trace(e);
                }
                else {
                    logging_1.logger.error(new parser_1.InternalError(String(e)).toString());
                }
            }
        }
    }
    return codeConnectObjects;
}
async function handlePublish(cmd) {
    setupHandler(cmd);
    let dir = cmd.dir ?? process.cwd();
    const projectInfo = (0, project_1.getProjectInfo)(dir, cmd.config);
    if (cmd.dryRun) {
        logging_1.logger.info(`Files that would be published:`);
    }
    const codeConnectObjects = await getCodeConnectObjects(dir, cmd, projectInfo);
    const storybookCodeConnectObjects = await (0, convert_1.convertStorybookFiles)({
        projectInfo,
    });
    const allCodeConnectFiles = codeConnectObjects.concat(storybookCodeConnectObjects);
    if (allCodeConnectFiles.length === 0) {
        logging_1.logger.warn(`No Code Connect files found in ${dir} - Make sure you have configured \`include\` and \`exclude\` in your figma.config.json file correctly, or that you are running in a directory that contains Code Connect files.`);
        process.exit(0);
    }
    const accessToken = getAccessToken(cmd);
    if (!accessToken) {
        logging_1.logger.error(`Couldn't find a Figma access token. Please provide one with \`--token <access_token>\` or set the FIGMA_ACCESS_TOKEN environment variable`);
        process.exit(1);
    }
    if (cmd.skipValidation) {
        logging_1.logger.info('Validation skipped');
    }
    else {
        logging_1.logger.info('Validating Code Connect files...');
        var start = new Date().getTime();
        const valid = await (0, validation_1.validateDocs)(accessToken, allCodeConnectFiles);
        if (!valid) {
            process.exit(1);
        }
        else {
            var end = new Date().getTime();
            var time = end - start;
            logging_1.logger.info(`All Code Connect files are valid (${time}ms)`);
        }
    }
    if (cmd.dryRun) {
        logging_1.logger.info(`Dry run complete`);
        process.exit(0);
    }
    (0, upload_1.upload)({ accessToken, docs: allCodeConnectFiles });
}
async function handleUnpublish(cmd) {
    setupHandler(cmd);
    let dir = cmd.dir ?? process.cwd();
    if (cmd.dryRun) {
        logging_1.logger.info(`Files that would be unpublished:`);
    }
    let nodesToDeleteRelevantInfo;
    if (cmd.node) {
        nodesToDeleteRelevantInfo = [
            { figmaNode: cmd.node, label: 'React' },
            { figmaNode: cmd.node, label: 'Storybook' },
        ];
    }
    else {
        const projectInfo = (0, project_1.getProjectInfo)(dir, cmd.config);
        const codeConnectObjects = await getCodeConnectObjects(dir, cmd, projectInfo);
        const storybookCodeConnectObjects = await (0, convert_1.convertStorybookFiles)({
            projectInfo,
        });
        const allCodeConnectFiles = codeConnectObjects.concat(storybookCodeConnectObjects);
        nodesToDeleteRelevantInfo = allCodeConnectFiles.map((doc) => ({
            figmaNode: doc.figmaNode,
            label: doc.label,
        }));
        if (cmd.dryRun) {
            logging_1.logger.info(`Dry run complete`);
            process.exit(0);
        }
    }
    const accessToken = getAccessToken(cmd);
    (0, delete_docs_1.delete_docs)({
        accessToken,
        docs: nodesToDeleteRelevantInfo,
    });
}
async function handleParse(cmd) {
    setupHandler(cmd);
    // if we're not doing a dry run, we don't want to output logs
    if (!cmd.dryRun) {
        logging_1.logger.setLogLevel(logging_1.LogLevel.Error);
    }
    let dir = cmd.dir ?? process.cwd();
    const projectInfo = (0, project_1.getProjectInfo)(dir, cmd.config);
    const codeConnectObjects = await getCodeConnectObjects(dir, cmd, projectInfo);
    const storybookCodeConnectObjects = await (0, convert_1.convertStorybookFiles)({
        projectInfo,
    });
    const allCodeConnectFiles = codeConnectObjects.concat(storybookCodeConnectObjects);
    if (cmd.dryRun) {
        logging_1.logger.info(`Dry run complete`);
        process.exit(0);
    }
    if (cmd.outfile) {
        fs_1.default.writeFileSync(cmd.outfile, JSON.stringify(codeConnectObjects, null, 2));
        logging_1.logger.info(`Wrote Code Connect JSON to ${(0, logging_1.highlight)(cmd.outfile)}`);
    }
    else {
        // don't format the output, so it can be piped to other commands
        console.log(JSON.stringify(allCodeConnectFiles, undefined, 2));
    }
}
function handleCreate(nodeUrl, cmd) {
    setupHandler(cmd);
    if (cmd.dryRun) {
        process.exit(0);
    }
    const accessToken = getAccessToken(cmd);
    if (!accessToken) {
        logging_1.logger.error(`Couldn't find a Figma access token. Please provide one with \`--token <access_token>\` or set the FIGMA_ACCESS_TOKEN environment variable`);
        process.exit(1);
    }
    return (0, create_1.createCodeConnectFromUrl)({
        accessToken,
        // We remove \s to allow users to paste URLs inside quotes - the terminal
        // paste will add backslashes, which the quotes preserve, but expected user
        // behaviour would be to strip the quotes
        figmaNodeUrl: nodeUrl.replace(/\\/g, ''),
        outFile: cmd.outfile,
    });
}
//# sourceMappingURL=connect.js.map
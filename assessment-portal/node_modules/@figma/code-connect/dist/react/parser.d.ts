import ts from 'typescript';
import { CodeConnectConfig } from '../common/project';
import { Intrinsic } from '../common/intrinsics';
interface ParserErrorContext {
    sourceFile: ts.SourceFile;
    node: ts.Node | undefined;
}
export declare class ParserError extends Error {
    sourceFilePosition: ts.LineAndCharacter | null;
    sourceFileName: string;
    constructor(message: string, context?: ParserErrorContext);
    toString(): string;
    toDebugString(): string;
}
export declare class InternalError extends ParserError {
    constructor(message: string);
}
export interface ParserContext {
    checker: ts.TypeChecker;
    sourceFile: ts.SourceFile;
    config: CodeConnectConfig | undefined;
}
/**
 * Parsers the `props` field of a `figma.connect()` call, returning a mapping of
 * prop names to their respective intrinsic types
 *
 * @param objectLiteral An object literal expression
 * @param parserContext Parser context
 * @returns
 */
export declare function parsePropsObject(objectLiteral: ts.ObjectLiteralExpression, parserContext: ParserContext): PropMappings;
export type PropMappings = Record<string, Intrinsic>;
/**
 * Extract metadata about the referenced React component. Used by both the
 * Code Connect and Storybook commands.
 *
 * @param parserContext Parser context
 * @param componentSymbol The ts.Symbol from the metadata referencing the
 * component being documented
 * @param node The node being parsed. Used for error logging.
 * @returns Metadata object
 */
export declare function parseComponentMetadata(node: ts.PropertyAccessExpression | ts.Identifier | ts.Expression, { checker, sourceFile }: ParserContext): Promise<{
    source: string;
    line: number;
    component: string;
}>;
/**
 * Checks if a file contains Code Connect by looking for the `figma.connect()` function call
 *
 * @param program
 * @param file
 * @returns
 */
export declare function isFigmaConnectFile(program: ts.Program, file: string): boolean;
/**
 * Parses the render function passed to `figma.connect()`, extracting the code and
 * any import statements matching the JSX elements used in the function body
 *
 * @param exp A function or arrow function expression
 * @param parserContext Parser context
 * @param propMappings Prop mappings object as returned by parseProps
 *
 * @returns The code of the render function and a list of imports
 */
export declare function parseRenderFunction(exp: ts.ArrowFunction | ts.FunctionExpression | ts.FunctionDeclaration, parserContext: ParserContext, propMappings?: PropMappings): {
    code: string;
    imports: {
        statement: string;
        file: string;
    }[];
    nestable: boolean;
};
export declare function getDefaultTemplate(componentMetadata: Awaited<ReturnType<typeof parseComponentMetadata>>): string;
export declare function parse(program: ts.Program, file: string, repoUrl?: string, config?: CodeConnectConfig, debug?: boolean): Promise<any[]>;
export {};
//# sourceMappingURL=parser.d.ts.map
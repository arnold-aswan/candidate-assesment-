"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveImportPath = exports.getProjectInfo = exports.getStorybookUrl = exports.getRemoteFileUrl = exports.getGitRemoteURL = void 0;
const child_process_1 = require("child_process");
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const typescript_1 = __importDefault(require("typescript"));
const logging_1 = require("./logging");
const DEFAULT_CONFIG_FILE_NAME = 'figma.config.json';
function parseConfig(configFilePath) {
    if (!fs_1.default.existsSync(configFilePath)) {
        return undefined;
    }
    try {
        const rawData = fs_1.default.readFileSync(configFilePath, 'utf-8');
        const config = JSON.parse(rawData);
        return config;
    }
    catch (error) {
        console.error('Error parsing config file:', error);
        return undefined;
    }
}
function getGitRemoteURL(repoPath) {
    try {
        const spawn = (0, child_process_1.spawnSync)('git', ['config', '--get', 'remote.origin.url'], {
            cwd: repoPath,
        });
        const output = spawn.stdout;
        return (output || '').toString().trim();
    }
    catch (error) {
        console.error('Error getting git remote URL:', error);
        return '';
    }
}
exports.getGitRemoteURL = getGitRemoteURL;
/**
 * Uses `git rev-parse` to find absolute path to the root of the git repository
 */
function getGitRepoAbsolutePath(filePath) {
    try {
        const spawn = (0, child_process_1.spawnSync)('git', ['rev-parse', '--show-toplevel'], {
            cwd: path_1.default.dirname(filePath),
        });
        const output = spawn.stdout;
        return (output || '').toString().trim();
    }
    catch (error) {
        console.error('Error running `git rev-parse`:', error);
        return '';
    }
}
/**
 * Finds the URL of a remote file
 * @param filePath absolute file path on disk
 * @param repoURL remote URL
 * @returns
 */
function getRemoteFileUrl(filePath, repoURL) {
    if (!repoURL) {
        return '';
    }
    let url = repoURL.trim();
    url = url.replace(':', '/');
    url = url.replace('git@', 'https://');
    url = url.replace(/\.git$/, '');
    // the folder of the git repo on disk could be named differently,
    // so we need to find the relative path of the file to the root of the repo
    // and append that to the remote URL
    const repoAbsPath = getGitRepoAbsolutePath(filePath);
    const index = filePath.indexOf(repoAbsPath);
    if (index === -1) {
        return '';
    }
    const relativeFilePath = filePath.substring(index + repoAbsPath.length);
    return `${url}/tree/master${relativeFilePath}`;
}
exports.getRemoteFileUrl = getRemoteFileUrl;
function getStorybookUrl(filePath, storybookUrl) {
    // the folder of the git repo on disk could be named differently,
    // so we need to find the relative path of the file to the root of the repo
    // and append that to the remote URL
    const repoAbsPath = getGitRepoAbsolutePath(filePath);
    const index = filePath.indexOf(repoAbsPath);
    if (index === -1) {
        return '';
    }
    const relativeFilePath = filePath.substring(index + repoAbsPath.length + 1); // +1 to remove the leading slash
    const storybookComponentPath = relativeFilePath
        .trim()
        .replace(/[\s|_]/g, '-')
        .replace(/\.[jt]sx?$/, '')
        .split('/')
        .join('-');
    return `${storybookUrl}/?path=/docs/${storybookComponentPath}`;
}
exports.getStorybookUrl = getStorybookUrl;
function mapToAbsolutePaths(globPaths, absPath) {
    return globPaths.map((globPath) => `${absPath}/${globPath}`);
}
/**
 * Gets information about a project from a directory.
 *
 * @param dir Directory containing the project
 * @param configPath Optional path to Code Connect config file
 * @returns Object containing information about the project
 */
function getProjectInfo(dir, configPath) {
    const configFilePath = configPath
        ? path_1.default.resolve(configPath)
        : path_1.default.resolve(path_1.default.join(dir, DEFAULT_CONFIG_FILE_NAME));
    const globalConfig = configFilePath ? parseConfig(configFilePath) : undefined;
    const config = globalConfig?.codeConnect;
    // `importPaths` and `paths` previously (incorrectly) lived in the global `codeConnect` config -
    // some early users may have it defined here so we'll log this error message to notify them to move it
    if (globalConfig && globalConfig.codeConnect.importPaths) {
        logging_1.logger.error(`The 'importPaths' option in the config file should be specified under 'react'`);
    }
    if (globalConfig && globalConfig.codeConnect.paths) {
        logging_1.logger.error(`The 'paths' option in the config file should be specified under 'react'`);
    }
    if (!globalConfig) {
        logging_1.logger.info(`No config file found in ${dir}, proceeding with default options`);
    }
    else if (globalConfig && !config) {
        logging_1.logger.info(`Config file found, but no options specified under 'codeConnect'. Parsing ${dir}`);
    }
    else if (config && !config.include) {
        logging_1.logger.info(`Config file found, but no include globs specified. Parsing ${dir}`);
    }
    else {
        logging_1.logger.info(`Config file found, parsing ${dir} using specified include globs`);
    }
    const absPath = path_1.default.resolve(dir);
    const includeGlobs = config?.include
        ? mapToAbsolutePaths(config.include, absPath)
        : `${absPath}/**/*.{tsx,jsx}`;
    const excludeGlobs = [
        ...(config?.exclude ? mapToAbsolutePaths(config.exclude, absPath) : []),
        `${absPath}/node_modules/**`,
    ];
    const files = (0, glob_1.globSync)(includeGlobs, {
        nodir: true,
        ignore: excludeGlobs,
    });
    const remoteUrl = getGitRemoteURL(absPath);
    const compilerOptions = {
        // This ensures the compiler can resolve imports such as "ui/button" when a
        // baseUrl is configured in the tsconfig of the project. We probably want a more
        // sophisticated way to parse the users tsconfig and pass it to the compiler eventually.
        baseUrl: absPath,
        // TODO: not sure why Node10 is needed her, but otherwise module resolution for
        // pnpm workspaces won't work
        moduleResolution: typescript_1.default.ModuleResolutionKind.Node10,
        paths: config?.react?.paths ?? {},
        allowJs: true,
    };
    const tsProgram = typescript_1.default.createProgram(files, compilerOptions);
    return {
        absPath,
        files,
        remoteUrl,
        config,
        tsProgram,
    };
}
exports.getProjectInfo = getProjectInfo;
function resolveImportPath(filePath, config) {
    function isMatch(patternParts, pathParts) {
        for (let i = 0; i < patternParts.length; i++) {
            if (patternParts[i] !== '*' && patternParts[i] !== pathParts[i]) {
                return false;
            }
        }
        return true;
    }
    for (const [key, value] of Object.entries(config.react?.importPaths || {})) {
        // Do a partial match from the end of the path
        const patternParts = key.split('/').reverse();
        const pathParts = filePath.split('/').reverse();
        if (pathParts.length < patternParts.length) {
            continue;
        }
        // If the mapped path ends with a wildcard we want to keep the filename in
        // the final path (for non-index imports)
        if (isMatch(patternParts, pathParts)) {
            return value.endsWith('*') ? `${value.slice(0, -1)}${pathParts[0].split('.')[0]}` : value;
        }
    }
    return null;
}
exports.resolveImportPath = resolveImportPath;
//# sourceMappingURL=project.js.map
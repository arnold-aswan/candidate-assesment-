"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.intrinsicToString = exports.valueMappingToString = exports.parseIntrinsic = exports.IntrinsicKind = exports.FIGMA_CONNECT_CALL = exports.API_PREFIX = void 0;
const ts = __importStar(require("typescript"));
const parser_1 = require("../react/parser");
const compiler_1 = require("../typescript/compiler");
const compiler_2 = require("../typescript/compiler");
const compiler_3 = require("../typescript/compiler");
exports.API_PREFIX = 'figma';
exports.FIGMA_CONNECT_CALL = `${exports.API_PREFIX}.connect`;
var IntrinsicKind;
(function (IntrinsicKind) {
    IntrinsicKind["Enum"] = "enum";
    IntrinsicKind["String"] = "string";
    IntrinsicKind["Boolean"] = "boolean";
    IntrinsicKind["Instance"] = "instance";
    IntrinsicKind["Children"] = "children";
})(IntrinsicKind || (exports.IntrinsicKind = IntrinsicKind = {}));
const Intrinsics = {};
/**
 * These functions are used to convert "intrinsic" parser types (which are calls to helper functions
 * like `Figma.boolean() in code)` to an object representing that intrinsic that we can serialize to JSON.
 *
 * Each call to `makeIntrinsic` should take a function from the {@link FigmaConnectAPI},
 * ensuring that the name of the intrinsic that we're parsing matches the name of the function
 *
 * @param staticFunctionMember
 * @param obj
 */
function makeIntrinsic(intrinsicName, obj) {
    const name = `${exports.API_PREFIX}.${intrinsicName}`;
    Intrinsics[name] = {
        match: (exp) => {
            return ts.isCallExpression(exp) && exp.getText().startsWith(name);
        },
        ...obj(name),
    };
}
makeIntrinsic('boolean', (name) => {
    return {
        parse: (exp, ctx) => {
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, ctx.sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            const valueMappingArg = exp.arguments?.[1];
            let valueMapping;
            if (valueMappingArg) {
                (0, compiler_3.assertIsObjectLiteralExpression)(valueMappingArg, ctx.sourceFile, `${name} second argument should be an object literal, that sets values for 'true' and 'false'`);
                valueMapping = (0, compiler_2.convertObjectLiteralToJs)(valueMappingArg, ctx.sourceFile, ctx.checker, (valueNode) => {
                    if (ts.isCallExpression(valueNode)) {
                        return parseIntrinsic(valueNode, ctx);
                    }
                });
            }
            return {
                kind: IntrinsicKind.Boolean,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                    valueMapping,
                },
            };
        },
    };
});
makeIntrinsic('enum', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile, checker } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            const valueMapping = exp.arguments?.[1];
            (0, compiler_3.assertIsObjectLiteralExpression)(valueMapping, sourceFile, `${name} second argument should be an object literal, that maps Figma prop values to code`);
            return {
                kind: IntrinsicKind.Enum,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                    valueMapping: (0, compiler_2.convertObjectLiteralToJs)(valueMapping, sourceFile, checker, (valueNode) => {
                        if (ts.isCallExpression(valueNode)) {
                            return parseIntrinsic(valueNode, ctx);
                        }
                    }),
                },
            };
        },
    };
});
makeIntrinsic('string', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            return {
                kind: IntrinsicKind.String,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                },
            };
        },
    };
});
makeIntrinsic('instance', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            return {
                kind: IntrinsicKind.Instance,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                },
            };
        },
    };
});
makeIntrinsic('children', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const layerName = exp.arguments?.[0];
            const layers = [];
            if (ts.isStringLiteral(layerName)) {
                layers.push((0, compiler_1.stripQuotes)(layerName));
            }
            else if (ts.isArrayLiteralExpression(layerName) && layerName.elements.length > 0) {
                layerName.elements.forEach((el) => {
                    (0, compiler_1.assertIsStringLiteral)(el, sourceFile);
                    layers.push((0, compiler_1.stripQuotes)(el));
                });
            }
            else {
                throw new parser_1.ParserError(`Invalid argument to ${name}, should be a string literal or an array of strings`, {
                    node: layerName,
                    sourceFile,
                });
            }
            return {
                kind: IntrinsicKind.Children,
                args: {
                    layers,
                },
            };
        },
    };
});
/**
 * Parses a call expression to an intrinsic
 *
 * @param exp Expression to parse
 * @param parserContext parser context
 * @returns
 */
function parseIntrinsic(exp, parserContext) {
    for (const key in Intrinsics) {
        if (Intrinsics[key].match(exp)) {
            return Intrinsics[key].parse(exp, parserContext);
        }
    }
    throw new parser_1.ParserError(`Unknown intrinsic: ${exp.getText()}`, {
        node: exp,
        sourceFile: parserContext.sourceFile,
    });
}
exports.parseIntrinsic = parseIntrinsic;
function valueMappingToString(valueMapping) {
    // For enums (and booleans with a valueMapping provided), convert the
    // value mapping to an object.
    return ('{\n' +
        Object.entries(valueMapping)
            .map(([key, value]) => {
            if (typeof value === 'object' && 'kind' in value) {
                // Mappings can be nested, e.g. an enum value can be figma.instance(...)
                return `"${key}": ${intrinsicToString(value)}`;
            }
            else if (typeof value === 'boolean' ||
                typeof value === 'number' ||
                typeof value === 'undefined') {
                return `"${key}": ${value}`;
            }
            else {
                return `"${key}": '${value}'`;
            }
        })
            .join(',\n') +
        '}');
}
exports.valueMappingToString = valueMappingToString;
function intrinsicToString({ kind, args }) {
    switch (kind) {
        case IntrinsicKind.String:
        case IntrinsicKind.Instance: {
            // Outputs:
            // `const propName = figma.properties.string('propName')`, or
            // `const propName = figma.properties.boolean('propName')`, or
            // `const propName = figma.properties.instance('propName')`
            return `figma.properties.${kind}('${args.figmaPropName}')`;
        }
        case IntrinsicKind.Boolean: {
            if (args.valueMapping) {
                const mappingString = valueMappingToString(args.valueMapping);
                // Outputs: `const propName = figma.properties.boolean('propName', { ... mapping object from above ... })`
                return `figma.properties.boolean('${args.figmaPropName}', ${mappingString})`;
            }
            return `figma.properties.boolean('${args.figmaPropName}')`;
        }
        case IntrinsicKind.Enum: {
            const mappingString = valueMappingToString(args.valueMapping);
            // Outputs: `const propName = figma.properties.enum('propName', { ... mapping object from above ... })`
            return `figma.properties.enum('${args.figmaPropName}', ${mappingString})`;
        }
        case IntrinsicKind.Children: {
            // Outputs: `const propName = figma.properties.children(["Layer 1", "Layer 2"])`
            return `figma.properties.children([${args.layers.map((layerName) => `"${layerName}"`).join(',')}])`;
        }
        default:
            throw new parser_1.InternalError(`Unknown intrinsic: ${kind}`);
    }
}
exports.intrinsicToString = intrinsicToString;
//# sourceMappingURL=intrinsics.js.map